// Generated by CoffeeScript 1.6.3
/*
This file is part of the Mooch package.

Copyright Â© 2013 Erin Millard

For the full copyright and license information, please view the LICENSE
file that was distributed with this source code.
*/


(function() {
  var Server, util;

  util = require('util');

  module.exports = Server = (function() {
    function Server(options, request, http, moment, output) {
      if (request == null) {
        request = require('request');
      }
      if (http == null) {
        http = require('http');
      }
      if (moment == null) {
        moment = require('moment');
      }
      if (output == null) {
        output = process.stdout;
      }
      if (!options.consumerKey) {
        throw new Error('Consumer key is required.');
      }
      if (!options.consumerSecret) {
        throw new Error('Consumer secret is required.');
      }
      if (!options.twitterUri) {
        options.twitterUri = 'https://api.twitter.com';
      }
      this._options = options;
      this._request = request;
      this._http = http;
      this._moment = moment;
      this._output = output;
    }

    Server.prototype.listen = function(port, callback) {
      var _this = this;
      if (port == null) {
        port = 8000;
      }
      return this._obtainToken(function(error, token) {
        if (error) {
          _this._output.write('Unable to obtain bearer token, shutting down Mooch server.\n');
          if (callback) {
            callback(error);
          }
          return;
        }
        _this._token = token;
        return _this._handle(port, callback);
      });
    };

    Server.prototype.close = function(callback) {
      var _this = this;
      if (this._server) {
        this._output.write('Shutting down Mooch server... ');
        return this._server.close(function(error) {
          if (error) {
            _this._output.write('failed.\n');
            if (callback) {
              callback(error);
            }
            return;
          }
          delete _this._server;
          _this._output.write('done.\n');
          if (callback) {
            return callback(null);
          }
        });
      }
    };

    Server.prototype._obtainToken = function(callback) {
      var options,
        _this = this;
      options = {
        uri: this._options.twitterUri + '/oauth2/token',
        method: 'POST',
        headers: {
          authorization: util.format('Basic %s', this._generateRequestToken())
        },
        form: {
          grant_type: 'client_credentials'
        }
      };
      this._output.write('Obtaining bearer token... ');
      return this._request(options, function(error, response, body) {
        var responseVariables;
        if (error) {
          _this._output.write('unknown error.\n');
          if (callback) {
            return callback(error);
          }
        } else {
          if (response.statusCode === 200) {
            responseVariables = JSON.parse(body);
            _this._output.write('done.\n');
            if (callback) {
              return callback(null, responseVariables.access_token);
            }
          } else {
            _this._output.write(util.format('HTTP error (%s).\n', response.statusCode));
            if (callback) {
              return callback(response);
            }
          }
        }
      });
    };

    Server.prototype._handle = function(port, callback) {
      var _this = this;
      this._server = this._http.createServer(function(request, response) {
        var requestBody;
        requestBody = '';
        request.on('readable', function() {
          return requestBody += request.read();
        });
        return request.on('end', function() {
          var contentLength, innerRequest, options, property;
          options = {
            uri: _this._options.twitterUri + request.url,
            method: request.method,
            headers: request.headers,
            body: requestBody,
            followRedirect: false
          };
          for (property in options.headers) {
            if (property.toLowerCase() === 'host') {
              delete options.headers[property];
            }
          }
          if (options.headers.authorization == null) {
            options.headers.authorization = util.format('Bearer %s', _this._token);
          }
          contentLength = 0;
          innerRequest = _this._request(options);
          innerRequest.on('data', function(chunk) {
            return contentLength += chunk.length;
          });
          innerRequest.on('end', function() {
            return _this._output.write(util.format('%s - - [%s] "%s %s HTTP/%s" %s %s\n', request.connection.remoteAddress, _this._moment().format('DD/MMM/YYYY:HH:mm:ss ZZ'), request.method, request.url, request.httpVersion, response.statusCode, contentLength || '-'));
          });
          return innerRequest.pipe(response);
        });
      });
      this._server.on('listening', function() {
        _this._output.write(util.format('Mooch listening on port %d.\n', port));
        if (callback) {
          return callback(null);
        }
      });
      return this._server.listen(port);
    };

    Server.prototype._generateRequestToken = function() {
      var encodedConsumerKey, encodedConsumerSecret, encodedRequestPair;
      encodedConsumerKey = encodeURIComponent(this._options.consumerKey);
      encodedConsumerSecret = encodeURIComponent(this._options.consumerSecret);
      encodedRequestPair = util.format('%s:%s', encodedConsumerKey, encodedConsumerSecret);
      return new Buffer(encodedRequestPair).toString('base64');
    };

    return Server;

  })();

}).call(this);
