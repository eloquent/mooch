// Generated by CoffeeScript 1.6.3
/*
This file is part of the Mooch package.

Copyright Â© 2013 Erin Millard

For the full copyright and license information, please view the LICENSE
file that was distributed with this source code.
*/


(function() {
  var Logger, Server, querystring, url, util;

  querystring = require('querystring');

  url = require('url');

  util = require('util');

  Logger = require('./Logger');

  module.exports = Server = (function() {
    function Server(options, request, http, logger) {
      if (request == null) {
        request = require('request');
      }
      if (http == null) {
        http = require('http');
      }
      if (logger == null) {
        logger = new Logger;
      }
      if (!options.consumerKey) {
        throw new Error('Consumer key is required.');
      }
      if (!options.consumerSecret) {
        throw new Error('Consumer secret is required.');
      }
      if (!options.twitterUri) {
        options.twitterUri = 'https://api.twitter.com';
      }
      if (!options.allow) {
        options.allow = [];
      }
      if (!options.deny) {
        options.deny = [];
      }
      this._options = options;
      this._request = request;
      this._http = http;
      this._logger = logger;
    }

    Server.prototype.listen = function(port, callback) {
      var _this = this;
      if (port == null) {
        port = 8000;
      }
      return this._obtainToken(function(error, token) {
        if (error) {
          _this._logger.error('Unable to obtain bearer token, shutting down.');
          if (callback) {
            callback(error);
          }
          return;
        }
        _this._token = token;
        return _this._handle(port, callback);
      });
    };

    Server.prototype._obtainToken = function(callback) {
      var options,
        _this = this;
      options = {
        uri: this._options.twitterUri + '/oauth2/token',
        method: 'POST',
        headers: {
          authorization: util.format('Basic %s', this._generateRequestToken())
        },
        form: {
          grant_type: 'client_credentials'
        }
      };
      this._logger.log('info', 'Obtaining bearer token.');
      return this._request(options, function(error, response, body) {
        var responseVariables;
        if (error) {
          _this._logger.error('Unable to obtain bearer token. Unexpected error.');
          if (callback) {
            return callback(error);
          }
        } else {
          if (response.statusCode === 200) {
            responseVariables = JSON.parse(body);
            _this._logger.log('info', 'Successfully obtained bearer token.');
            if (callback) {
              return callback(null, responseVariables.access_token);
            }
          } else {
            _this._logger.error('Unable to obtain bearer token. Unexpected HTTP error (%s).', response.statusCode);
            if (callback) {
              return callback(response);
            }
          }
        }
      });
    };

    Server.prototype._handle = function(port, callback) {
      var _this = this;
      this._server = this._http.createServer(function(request, response) {
        var requestBody;
        if (!_this._requestAllowed(request)) {
          response.writeHead(403, {
            'content-type': 'application/json'
          });
          response.end('{"errors":[{"message":"Forbidden.","code":64}]}');
          _this._logger.log('info', 'Client denied by configuration rules.');
          _this._logger.log('request', '%s "%s %s HTTP/%s" 403 -', request.connection.remoteAddress, request.method, request.url, request.httpVersion);
          return;
        }
        requestBody = '';
        request.on('readable', function() {
          return requestBody += request.read();
        });
        return request.on('end', function() {
          var contentLength, innerRequest, options, property;
          options = {
            uri: _this._options.twitterUri + request.url,
            method: request.method,
            headers: request.headers,
            body: requestBody,
            followRedirect: false
          };
          for (property in options.headers) {
            if (property.toLowerCase() === 'host') {
              delete options.headers[property];
            }
          }
          if (options.headers.authorization == null) {
            options.headers.authorization = util.format('Bearer %s', _this._token);
          }
          contentLength = 0;
          innerRequest = _this._request(options);
          innerRequest.on('data', function(chunk) {
            return contentLength += chunk.length;
          });
          innerRequest.on('end', function() {
            return _this._logger.log('request', '%s "%s %s HTTP/%s" %s %s', request.connection.remoteAddress, request.method, request.url, request.httpVersion, response.statusCode, contentLength || '-');
          });
          return innerRequest.pipe(response);
        });
      });
      this._server.on('listening', function() {
        _this._logger.log('info', 'Listening on port %d.', port);
        if (callback) {
          return callback(null);
        }
      });
      return this._server.listen(port);
    };

    Server.prototype._generateRequestToken = function() {
      var encodedConsumerKey, encodedConsumerSecret, encodedRequestPair;
      encodedConsumerKey = encodeURIComponent(this._options.consumerKey);
      encodedConsumerSecret = encodeURIComponent(this._options.consumerSecret);
      encodedRequestPair = util.format('%s:%s', encodedConsumerKey, encodedConsumerSecret);
      return new Buffer(encodedRequestPair).toString('base64');
    };

    Server.prototype._requestAllowed = function(request) {
      var allowMatched, normalizedUri, pattern, uriParts, _i, _j, _len, _len1, _ref, _ref1;
      uriParts = url.parse(request.url);
      normalizedUri = url.format({
        pathname: decodeURIComponent(uriParts.pathname),
        search: querystring.stringify(querystring.parse(uriParts.query))
      });
      allowMatched = this._options.allow.length < 1;
      _ref = this._options.allow;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pattern = _ref[_i];
        if (normalizedUri.match(pattern)) {
          allowMatched = true;
          break;
        }
      }
      if (!allowMatched) {
        return false;
      }
      _ref1 = this._options.deny;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        pattern = _ref1[_j];
        if (normalizedUri.match(pattern)) {
          return false;
        }
      }
      return true;
    };

    return Server;

  })();

}).call(this);
